/////////////////////////
//无向图 n点n边

//适用于只有一个环的基环树
//
//找环操作
//1.计算所有点的度(点u的边连接数)
//2.把度为1的点全部入队
//3.易次出队,删边
//4.如果邻居度数为1则入队
//5.基于拓扑排序的bfs完成后《度数>1》的点即为环上的点

for(int i=1;i<=n;i++)
    if(d[i] == 1)
        q.push(i);

while(q.size()){
    int u = q.front(); q.pop();
    for(auto v : g[u]){
        if(--d[v] == 1){
            q.push(v);
        }
    }
}

d[u] > 1 => u在环上

/////////////////////////
//有向图
//内向基环树 每个点出度为1
//内向基环树 可以转换为 外向基环树

//外向基环树 每个点入度为1

//外向基环树找环上一点
int find(int u){
    vis[u] = true;
    int fa = father[u];
    if(vis[fa]) return fa;
    return find(fa);
}

//在内向基环树的环上一点开始bfs
//bfs完毕后入过队的点均为环上的点